\documentclass[11pt,a4paper]{article}
\usepackage[margin=1in]{geometry}
\usepackage{calc}
\usepackage{helvet}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage[hidelinks]{hyperref}
\usepackage{url}
%\usepackage{float} How to install this?
%\usepackage{cleveref} How to install this?
\graphicspath{./src/}

% Break URL on hyphens
\makeatletter
\g@addto@macro{\UrlBreaks}{\UrlOrds}
\makeatother

\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt} % Remove line
\fancyfoot[R]{Version \input{|"git rev-parse --short HEAD"}}
\fancyhead[C]{\leftmark}
\fancyfoot[L]{\thepage}

\setlength{\parindent}{0cm}  % No indent on pararaph

\newlength\myheight
\newlength\mydepth
\settototalheight\myheight{Xygp}
\settodepth\mydepth{Xygp}
\setlength\fboxsep{0pt}
\newcommand*\inlinegraphics[1]{%
  \settototalheight\myheight{Xygp}%
  \settodepth\mydepth{Xygp}%
  \raisebox{-\mydepth}{\includegraphics[height=\myheight]{#1}}%
}

\newcommand{\instructionbox}[2]{\medskip%
\fbox{\begin{minipage}{\textwidth}%
    \medskip%
    \begin{center}%
        #1%
    \end{center}%
    \medskip%
\end{minipage}}%
\medskip%
}

\newcommand{\handwaving}{\inlinegraphics{./src/hand.png}}

\title{VHDL 101}
\author{Patrick Mintram}

\begin{document}

\clearpage\maketitle
\thispagestyle{empty} % No page numbering
\pagebreak

\section{Intoduction}
Things this session is intended to wet your appetite to the world of FPGAs, so that if you choose to you can start having a play in your own time. This session is:
\begin{enumerate}
    \item A brief overview of VHDL
    \item A chance to get hands on with some Hardware
    \item A chance to make a \texttt{hello world} in Hardware
\end{enumerate}

Things this session is not:
\begin{enumerate}
    \item An introduction to Digital Design
    \item A comprehensive deep dive into VHDL
    \item Likely to finish on time
\end{enumerate}

By the end of this session you should have configured an FPGA to react to a switch input, and to see that output on an LED.

\section{How to use this guide}
It is not expected that session participants follow this document step by step. It expected that participants reference it to work at own pace, or to be able to recreate the work in their own time. Participants are encouraged to make notes are they require on this document, once printed. 

The hand \handwaving icon will appear when something is purposely had some handwaving applied to it to keep it simple.

\instructionbox{Anything in a box is an instruction to complete, like 'click this' or 'type this'}

\subsection{Terminology}
This document contains a number of terms which may be new to people so a brief overview of these follows:
\begin{itemize}
    \item \textbf{HDL} stands for Hardware Description Language, of which VHDL is one. Others include Verilog, System Verilog and System C. There are of course many more, but these 4 are the ones that I have come across most. Note that these are specifically used to describe digital circuits, if you want to describe analog circuits there are flavours such as Verilog-AMS(Analog and Mixed-Signal) or VHDL-AMS(Analog/Mixed-Signal Extension), I have never come across these in the wild though.
    \item \textbf{Entity} is a keyword in VHDL. Each item you describe in VHDL is in an \emph{entity} and is split into two parts; the entity \emph{declaration} and the entity \emph{architecture}.
    \item \textbf{Module} is not a keyword in VHDL, but at a high level the term may be banded around as a way of describing a distinct design unit, e.g. an entity is a module of an overall design.
    \item \textbf{Architecture} is another keyword. The architecture of an entity is it's implementation details. An entity may have more than one architecture, where the one instantiated can be selected via a configuration.
    \item \textbf{Dataflow} is a type of architecture implementation in which the source code describes the flow of data in the module, and leaves the structure of the design up to the toolchain.
    \item \textbf{Behavioural} is a type of architecture implementation in which the source code describes the behaviour of the module. This is most familiar to us as software engineers as it is a high level description of the module using abstractions such as \texttt{if} \texttt{else} etc. This may not be the most efficient way of doing the job, but it's relatively quick and easier to understand, even if it's not synthesisable. \emph{Writing the flowchart}
    \item \textbf{RTL} is a type of architecture implementation in which the source code is fully synthesisable may go into detail about the gates in the module. \emph{Writing the circuit diagram}
    \item \textbf{Synthesis} is the process of turning your description into blocks of hardware.\handwaving There are a number of steps to turning VHDL source code into a format actually usable by an FPGA, and often people refer to the process as compilation or synthesis. 
    \item \textbf{PMOD}s are a type of plug in INFOMATION HERE
\end{itemize}

\pagebreak
\tableofcontents
\listoffigures
\pagebreak

\setlength{\parskip}{\medskipamount}

\section{Why Should I Care?}
FPGAs enable Low Latency processing \footnote{\url{https://blog.esciencecenter.nl/why-use-an-fpga-instead-of-a-cpu-or-gpu-b234cd4f309c}}, so performing a transform on data coming in and getting the result output an be much faster than in a traditional CPU based approach. They also provide far more IO configurability than the traditional approach; the IO logic, and the pin it's connected to are totally configurable in code and constraints files\handwaving. Say a requirement changes from an 8 bit UART bus to a proprietary 11 bit UART bus - this would require a whole new microcontroller in a traditional approach however with an FPGA this might only require a change to a \texttt{generic} and a recompile. 

For the reasons stated above, typical uses include signal processing such as filtering \footnote{\url{https://digital-library.theiet.org/content/journals/10.1049/iet-cdt.2016.0067}}, and High Speed IO such as devices produced by SpeedGoat \footnote{\url{https://www.speedgoat.com/products/simulink-programmable-fpgas-fpga-i-o-modules-io334}}.
\subsection{Toolchain}
One important takeaway from this is that toolchains are important. Each device vendor will have their own proprietary toolchain. This means that you can approach FPGA development in one of two ways:
\begin{itemize}
    \item Choose a toolchain you're familiar with, then a device from the manufacturer PUT IN LOGO
    \item Choose a device which suits your requirements, then potentially suffer with an unfamiliar toolchain PUT IN LOGO
\end{itemize}

Fortunately there are few realistic choices when it comes to this decision; use the Quartus toolchain with Intel \footnote{Altera} devices, or using the Vivado toolchain\footnote{Older Xilinx devices can use the ISE suit from Xilinx} with Xilinx devices. I am most familiar with Vivado, so this workshop is based around that. The reason for this choice is that the \emph{Zynq} range of devices from Xilinx are a System on Chip (SOC) which allows me to use either the ARM core or some Programmable Logic in any projects I'm undertaking. Similar devices may exist from the Intel range, but at the time of buying my dev board they didn't. For an overview of some devices you might come across see Table \ref{table:devices}.

\begin{center}
    \begin{table}
        \begin{tabular}{|c|c|c|}
            \hline
            Manufacturer & Toolchain & Device \\ \hline
            Intel & Quartus & SOME BOARDS \\ \hline
            Xilinx & Vivado & SOME BOARDS \\ \hline
             & ghdl & \\ \hline
            ICE & IceBreaker & Lattice \\ \hline
        \end{tabular}
        \caption{An overview of devices you might come across}
        \label{table:devices}
    \end{table}
\end{center}

There is also a third option when it comes to toolchains; if you don't care about synthesis a well known simulation tool is \texttt{ghdl}. This allows for your VHDL code to be written, analysed, elaborated, and and testbenches run very quickly and without any synthesis. One of the obvious limitations with this is that it doesn't allow you to put the hardware onto a board. There are plenty of docs available online to reference when it comes to using this and this projects \texttt{build.sh} in the \texttt{scripts} directory might help as a starting point.  

I have seen on twitter lots of talk of the Lattice; this seems to be an open source FPGA and toolchain. 

\section{Important things to remember}
There is one main things to remember: \textbf{It's not software it's hardware}. Everything you do should be done with the hardware you're creating in the back of your mind. You should make sure you are familiar with the design guidance for your device of choice. This is because different devices are made of different things - the Xilinx guidance for example states THIS ABOUT THE ZYNQ DEVICES.

\section{Finally lets get to doing some VHDL}
\subsection{Reference Project}
The reference project provided enables you to flash some LEDs at different speeds - this demonstrates the ability to create designs with different things happening at different times and at different rates. It also contains some stubs for you to put in your own functionality; turning off and on an LED from a switch. 
\subsubsection{File Types}
A VHDL project will typically contain the following files:
\begin{enumerate}
    \item Design Source Files \texttt{*.vhd}: These contain the actual source code for the hardware you're describing. These should contain only synthesisable code.
    \item Design Test Benches \texttt{*\_tb.vhd}: These contain test benches for your design entities, usually suffixed with \texttt{\_tb} so you know it's a test bench, and will likely contain non synthesisable code.
    \item Constraints Files \texttt{*.\{ucf|xcd\}}: These files describe any constraints of the platform or design, such as pins used, timing requirements etc.
    \item Scripts \texttt{*.\{sh|tcl\}}: These are provided to help with setting up and managing the project. \texttt{tcl} files seem to be what most tools prefer, and tools will often provide a number of utility functions to help with this. 
\end{enumerate}

This will be an overview of the reference project
\subsection{How to see output from our VHDL}
\subsubsection{Simulation}
How to interpret the waveforms
\subsubsection{On the hardware itself}
How to load onto the board

\section{Further Activities}
If this has been fun, and you want to learn more here are some useful resources I have had successes with:

\begin{itemize}
    \item Effective Coding with VHDL\footnote{\url{https://www.amazon.co.uk/Effective-Coding-VHDL-Principles-Practice/dp/0262034220}} 
    \item Awesome VHDL \footnote{\url{https://github.com/VHDL/awesome-vhdl}}
    \item Digital Fundamentals \footnote{\url{https://www.amazon.co.uk/Digital-Fundamentals-Thomas-L-Floyd/dp/0132737965}}
\end{itemize}

\end{document}
